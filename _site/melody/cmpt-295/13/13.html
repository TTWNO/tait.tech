<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> | tait.tech</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/assets/css/katex.css">
  
</head>
<body>
  <main>
    <div id="wrapper">
      <h1 id="cmpt-295">CMPT 295</h1>

<ul>
  <li>Unit - Machine-Level Programming</li>
  <li>Lecture 13 – Assembly language – Program Control – cmovX</li>
  <li>Iterative Statements – Loops</li>
</ul>

<h2 id="last-lecture">Last Lecture</h2>

<ul>
  <li>In C, we can change the execution flow of a program
    <ol>
      <li>Conditionaly
        <ul>
          <li>Conditional statements: if/else, switch</li>
          <li>Iterative statements: loops</li>
        </ul>
      </li>
      <li>Unconditionally
        <ul>
          <li>Functions calls</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>In x86-64 assembly, we can also change the execution flow of a program
    <ul>
      <li>cmp* instruction (compare)</li>
      <li>jX insturction (jump)</li>
      <li>call and ret instructions</li>
    </ul>
  </li>
</ul>

<h2 id="todays-menu">Today’s Menu</h2>

<ul>
  <li>Introduction
    <ul>
      <li>C program -&gt; assembly code -&gt; machine level code</li>
    </ul>
  </li>
  <li>Assembly language basics: data, move operation
    <ul>
      <li>Memory addressing modes</li>
    </ul>
  </li>
  <li>Operation leaq and Arithmetic &amp; logical operations</li>
  <li>Conditional Statement – Condition Code + cmovX</li>
  <li>(highlighted) Loops</li>
  <li>Function call – Stack</li>
  <li>Array</li>
  <li>Buffer Overflow</li>
  <li>Floating-point operations</li>
</ul>

<h2 id="homework-int-maxint-x-int-y">Homework: <code class="language-plaintext highlighter-rouge">int max(int x, int y)</code></h2>

<p>In C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int max(int x,int y){
  int result = x;
  if(y&gt;x)
    result=y;
  return result;
}
</code></pre></div></div>

<p>version 1 – with jX instruction</p>

<p>In Assembly: # x in %edi, y in %esi, result in %eax</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>max:
  movl %edi,%eax #result=x
  cmpl %edi,%esi #if y&lt;=x then
  jle endif #return
  movl %esi,%eax #result=y
endif:
  ret
</code></pre></div></div>

<p>We branch (jump) when the condition (y &gt; x) is false, i.e., when (y &lt;= x)
-&gt; This technique is called “coding the false condition first”
or ”taking care of …”</p>

<h2 id="conditional-move-instruction-cmovx">Conditional move instruction cmovX</h2>

<p>What C code looks like when using conditional operator:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result=test?val2:val1;
return result;
</code></pre></div></div>

<p>What logic of assembly
code looks like when using
cmovX (expressed in C):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result=val1;
if (test) result = val2;
return result;
</code></pre></div></div>

<p>Example: <code class="language-plaintext highlighter-rouge">cmovle Src,Dest</code></p>

<p>Alternative: <code class="language-plaintext highlighter-rouge">int abs(int x)</code></p>

<p>In C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int abs(int x){
  if(x&lt;0)
    x=-x;
  return x;
}
</code></pre></div></div>

<p>in assembly: # <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">%edi</code>, <code class="language-plaintext highlighter-rouge">result</code> in <code class="language-plaintext highlighter-rouge">%eax</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abs:
  movl %edi,%eax # result = x
  negl %edi # x = -x
  cmpl $0,%eax # if x &lt; 0 then
  cmovl %edi,%eax # result = -x
  ret
</code></pre></div></div>

<h2 id="advantage-of-conditional-move-cmovx">Advantage of conditional move cmovX</h2>

<p>Note about branching:</p>

<ul>
  <li>Branches are very disruptive to instruction flow through
microprocessor CPU pipelines</li>
  <li>However, since conditional moves (cmovX) do not
require control transfer (no branching/jumping required),
they are less disruptive</li>
  <li>So, <code class="language-plaintext highlighter-rouge">gcc</code> tries to use them, but only when safe</li>
</ul>

<h2 id="what-do-we-mean-by-safe">What do we mean by “safe”?</h2>

<ul>
  <li>In <code class="language-plaintext highlighter-rouge">result = test ? aVal : anotherVal;</code> both values
(<code class="language-plaintext highlighter-rouge">aVal</code> and <code class="language-plaintext highlighter-rouge">anotherVal</code>) are computed so their
computation must be “safe”</li>
  <li>Example of unsafe computations:
    <ol>
      <li>Expensive computations <code class="language-plaintext highlighter-rouge">val = Test(x) ? Hard1(x) : Hard2(x);</code>
        <ul>
          <li>Only makes sense when computations are very simple</li>
        </ul>
      </li>
      <li>Risky computations <code class="language-plaintext highlighter-rouge">val = p ? *p : 0;</code>
        <ul>
          <li>Only makes sense when computations do not crash the application</li>
        </ul>
      </li>
      <li>Computations with side effects <code class="language-plaintext highlighter-rouge">val = x &gt; 0 ? x*=7 : x+=3;</code>
        <ul>
          <li>Only makes sense when computations do not have side effects</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="homework-example-alternate-int-maxint-x-int-y">Homework: Example: alternate <code class="language-plaintext highlighter-rouge">int max(int x, int y)</code></h2>

<p>version 2 – with cmovX instruction</p>

<p>In C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int max(int x, int y){
  int result = x;
  if(y&gt;x)
    result = y;
  return result;
}
</code></pre></div></div>

<p>In Assembly: # x in %edi, y in %esi, result in %eax</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>max:
  movl %edi,%eax #result=x
  cmpl %edi,%esi #if y&gt;x then
  cmovg %esi,%eax #result=y
  ret
</code></pre></div></div>

<h2 id="while-loop--coding-the-false-condition-first">While loop – “coding the false condition first”</h2>

<p><code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">int y</code> are arguments to function</p>

<p>in C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(x&lt;y){
  //stmts
}
return;
</code></pre></div></div>

<p>in assembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop:
  _____
  _____
  _____
  _____ 
  _____
  _____
  _____
endloop:
  ret
</code></pre></div></div>

<p>Loop Pattern 1</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop:
  if cond false
    goto done:
  stmts
  goto loop:
done:
</code></pre></div></div>

<h2 id="while-loop--jump-to-middle">While loop – “jump-to-middle”</h2>

<p><code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">int y</code> are arguments to function</p>

<p>in C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(x&lt;y){
  //stmts
}
return;
</code></pre></div></div>

<p>in assembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop:
  # stmts
test:
  ____
  ____
  ____
  ____
  ret
</code></pre></div></div>

<p>Loop Pattern 2</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  goto test:
loop:
  # stmts
test:
  if cond true
    goto loop:
done:
</code></pre></div></div>

<h2 id="do-while-loop--jump-to-middle">Do While loop – “jump-to-middle”</h2>

<p><code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">int y</code> are arguments to function</p>

<p>in C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do{
  stmts
} while(x&lt;y);
return;
</code></pre></div></div>

<p>in assembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop:
  #stmts
test:
  ____
  ____
  ____
  ____
  ____
  ret
</code></pre></div></div>

<p>Loop Pattern 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(deleted) goto test:
loop:
  stmts
test:
  if cond true
    goto loop:
done:
</code></pre></div></div>

<h2 id="for-loop">For loop</h2>

<p>In C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//format: for(initialization; condition testing; increment)
for(int i=0;i&lt;n;++i){
  //stmts
}
return;
</code></pre></div></div>

<p>Becomes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i=0; // initialization
while(i&lt;n){// condition testing
  //stmts
  i++; //increment
}
return;
</code></pre></div></div>

<p>Which becomes, in Assembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  xorl %ecx, %ecx # initialization
loop:             # %ecx (i) &lt;- 0
  cmpl %edi, %ecx # while i &lt; n true (testing)
  jge endloop     # jump when i&gt;=n (false condition)
  #stmts
  incl %ecx       # i++ increment
  jmp loop        # loop again
endloop:
  ret
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>Compiler can produce different instruction combinations when assembling the same C code.</p>

<p><code class="language-plaintext highlighter-rouge">cmp*</code> and <code class="language-plaintext highlighter-rouge">test*</code> instructions set condition codes</p>

<ul>
  <li>In x86-64 assembly, there are no conditional statements, however,
we can alter the execution flow of a program by using …
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cmp*</code> instruction (compare)</li>
      <li><code class="language-plaintext highlighter-rouge">jX</code> instructions (jump)</li>
      <li><code class="language-plaintext highlighter-rouge">call</code> and ret instructions</li>
      <li><code class="language-plaintext highlighter-rouge">cmovX</code> instructions -&gt; conditional move</li>
    </ul>
  </li>
  <li>In x86-64 assembly, there are no iterative statements, however, we
can alter the execution flow of a program by using …
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cmp*</code> instruction</li>
      <li><code class="language-plaintext highlighter-rouge">jX</code> instructions (jump)</li>
    </ul>
  </li>
  <li>CPU uses these condition codes to decide whether a …
    <ul>
      <li><code class="language-plaintext highlighter-rouge">jX</code> instruction (conditional jump) is to be exectued or a</li>
      <li><code class="language-plaintext highlighter-rouge">cmovX</code> instruction (conditional move) is to be exectued</li>
    </ul>
  </li>
  <li>2 loop patterns:
    <ul>
      <li>“coding the false condition first” -&gt; <code class="language-plaintext highlighter-rouge">while</code> loops (hence <code class="language-plaintext highlighter-rouge">for</code> loops)</li>
      <li>“jump-in-middle” -&gt; <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">do-while</code> (hence for loops)</li>
    </ul>
  </li>
</ul>

<h2 id="next-lecture">Next Lecture</h2>

<ul>
  <li>Introduction
    <ul>
      <li>C program -&gt; assembly code -&gt; machine level code</li>
    </ul>
  </li>
  <li>Assembly language basics: data, move operation
    <ul>
      <li>Memory addressing modes</li>
    </ul>
  </li>
  <li>Operation leaq and Arithmetic &amp; logical operations</li>
  <li>Conditional Statement – Condition Code + cmovX</li>
  <li>Loops</li>
  <li>(highlighted) Function call – Stack
    <ul>
      <li>(highlighted) Overview of Function Call</li>
      <li>(highlighted) Memory Layout and Stack - x86-64 instructions and registers</li>
      <li>(highlighted) Passing control</li>
      <li>Passing data – Calling Conventions</li>
      <li>Managing local data</li>
    </ul>
  </li>
  <li>Array</li>
  <li>Buffer Overflow</li>
  <li>Floating-point operations</li>
</ul>

      <footer>
      </footer>
    </div>
  </main>
</body>
</html>
