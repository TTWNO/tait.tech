---
layout: simple
math: true
---

# Binary Search Trees

CMPT 225

## ADTs related to Sets

* Set: unordered collection of values/objects.
* Operations:
  * insert(x) // add x to set
  * member(x) // check if x in set. a.k.a. find(x), search(x), lookup(x), ...
  * remove(x) // remove x from set
  * size() // get size of set
  * empty() // is set empty
  * clear() // remove all elements (i.e., make set empty)
* We call the values we store *keys*,
* We assume the keys are from some *unordered set S*.
  * i.e. for any two keys $$x,y\in S$$, we have exactly one of $$x< y,x=y,y< x$$
* What implementaions where *all* operations are efficient/fast
  * Q: What will count as "fast"?

## ADTs related to Sets

Consider time complexity of operations ofr simple list + array implementations!

type|insert|find|remove
---|---|---|---
un-ordered array|(green) O(1)|O(n)|O(n)
ordered array|(red) O(n)|(purple outline) O(log n)|(red) O(n)
un-ordered linked list|(green) O(1)|(red) O(n)|(red) O(n)
ordered linked list|(red) O(n)|(red) O(n)|(red) O(n)

Q: What will count as "fast"?

A: Time O(log n) //n is size of set

## Some Related Container ADTs

* Multiset: like set, but with multiplicities (aka bag)
  * count(x)
* Map: unordered collection of &gt;key,value&lt; pairs, associating at most one value with each key. (e.g. partial function keys -> values)
  * put(key,val) // in place of insert(x)
  * get(key) // return value associated with key
* Dictionary: like map, but associates a collection of values with each key.

Implementations of these are simple abstractions to implementations of *sets*, which we focus on.

## Binary Search Tree (B.S.T.)

A BST is:

* a binary tree // a structure invariant
* with nodes labled by keys
* satisfying the following *order invariant*: for every two nodes u,v:
  * if u is in left subtree of v, then $$\text{key}(u) < \text{key}(v)$$
  * if u is in the right subtree of v, then $$\text{key}(u) > \text{key}(v)$$

## Ex. 

Example 1 (checked):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 2 (X):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 3 (check) (right and left are written explicitly when there are not two nodes to write. Otherwise, left is written first and right is listed second.):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     10 (right)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       20 (right)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         30 (right)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           25 (left)
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 4 (check):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Every sub-tree of a BST is a BST

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   500
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     200
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       100
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       300
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         250
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         350
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     700
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       600
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         650 (keys in this subtree would be &gt;600 , &lt;700)
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         560
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       800
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## This makes recursive algorithms very nature.

## Fact:

In-order traversal of a BST visits keys in non-decreasing order.

Proof sketch:

* Basic: $$h=0$$, so one node
* I.H.: the claim holds for all trees of $$\text{height} \leq h$$
* I.S.: T is: v with left tree of A and right tree of B. (A, B may b e empty)
* We:
  1. traverse A, visiting keys in sequence: $$a_{1}, a_{2}, \dots a_{k}$$
  2. visit v
  3. tranverse B, visiting keys in sequence  $$b_{1}, b_{2}, \dots b_{m}$$
* Overall, we visit: $$a_1, a_2, \dots a_k, b_1, b_2, \dots b_m$$
* By I.E. $$a_1 \leq a_2 \leq \dots \leq a_k$$
* $$b_1, \leq b_2 \leq \dots \leq b_m$$
* Because T is a BST, so:

{% katex display %}
a_k \leq \text{key}(v) < b_1\\
\therefore a_1 \leq a_2 \leq \dots \leq a_k \leq \text{keys}(v) \leq b_1 \leq b_2 \dots \leq b_m
{% endkatex %}

## BST Find/Search: examples

(Trasncriber's note: the links are the search path for the algorithms)

find(5):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="tree2_3">
   <a href="#tree2_8">3</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="tree2_8">
     <a href="#tree2_5">8</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree2_5">
       5 (check)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         6
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

find(1):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="three3_3">
   <a href="#tree3_8">3</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="three3_8">
     <a href="#tree3_5">8</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree3_5">
       <a href="#tree3_6">5</a>
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="tree3_6">
         6 (X)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Find 6:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree9-8">5</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="tree9-8">
     8 (right, X)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10 (right)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Some notation:

Suppose `v` is a node of BST. We write:

* left(v) = left child of v
* right(v) = right child of v
* key(v) = key labelling v
* node(v) node v s.t. key(v)=x

## BSD find(x) Pseudo-code

```
find(x){// return true iff t is in the tree.
  return find(t,root)
}

find(t,v)// return true if t appears in ubstree rooted at v.
{
  if t < key(v) & v has a left subtree
    return find(t, left(v))
  if t > key(v) & v has a right subtree
    return find(t, right(v))
  if key(v) = t
    return true
  return false //v is a leaf, does not have t
}
```

## BST find(t,v) pseudo-code -- alternate version 

```
find(t,v) // return true if t appears in subtree rooted at v
{
  if key(v)=t
    return true
  if t < key(v) & v has a left subtree
    return find(t,left(v))
  if t > key(v) & v has a right subtree
    return find(t,right(v))
  return false
}
```

Q: Which version is better?

A: key(v)=t will almsot always be false, so the first return should do fewer comparisons and usually be false.

## BST insert(x) Pseudo-code

```
insert(t){
  // adds t to the tree
  // assumes t is not in the tree already*
  u <- node at which find(t,root) terminates**
  if t<key(u)
    give u a new left child with key t.
  else
    give u a new right child with key t.
}
```

\* Excersise: Write the version that does not make this assumption.

\*\* Excersise: Write the version where the search is excplicit.

## BST Insert Examples

insert(1):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree11_2">3</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="tree11_2">
     <a href="#tree11_1">2</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree11_1">
       1 (inserted)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         6
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

insert(7):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree12_8">3</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="tree12_8">
     <a href="#tree12_5">8</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree12_5">
       <a href="#tree12_6">5</a>
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="tree12_6">
         <a href="#tree12_7">6</a>
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="tree12_7">
           7 (right)
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## BST insert(x) Pseudo-code -- explicit search version...

```
insert(t){ //adds t to the tree if it is not already there
  insert(t, root)
}
insert(t,v) //insert t in the subtree rooted at v, if it is not there
{
  if t < key(v) & v has a left subtree
    insert(t, left(v))
  if t > key(v) & v has a right subtree
    insert(t, right(v))
  if t < key(v) //here v has no left child
    give v a new left child with key t
  if t > key(v) //here v has no right child
    give v a new right child with key t.
  // if we reach here, t=key(v), so do nothing.
}
```

## Insertion Over for BSTs: Examples

### 1)

* start with an empty BST
* insert 5,2,3,7,8,1,6 in the given order

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       1
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       3
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

### 2)

* start with an empty BST
* insert 1,2,3,5,6,7,8 in the order given

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2 (right)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       3 (right)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         4 (right)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           5 (right)
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span>
             6 (right)
            </span>
            <ul role="group">
             <li role="treeitem" tabindex="-1">
              <span>
               7 (right)
              </span>
              <ul role="group">
               <li role="treeitem" tabindex="-1">
                <span>
                 8 (right)
                </span>
               </li>
              </ul>
             </li>
            </ul>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

### Notes

* Insertion order affects the shape of a BST.
* Removal order can too.

## BST remove(t)

We consider 3 cases, increasing difficulty.

1. Case 1: t is at a leaf ([example figure #1](#ex_fig_1)):
    1. find the node v with key(v)=t
    2. delete v
2. Case 2: t is a node with 1 child ([example figure #2](#ex_fig_2) and [example figure #3](#ex_fig_3))
    1. find the node v with key(v)=t
    2. let u be the child of v
    3. replace v with the subtree rooted at u
3. For case 3, see the [next section](#case3)

<h3 id="ex_fig_1">Example Figure #1</h3>

remove(7):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree13_8">5</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2 (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="tree13_8">
     <a href="#tree_7">8</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree13_7">
       7 (Xed out)
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

<h3 id="ex_fig_2">Example Figure #2</h3>

remove(3)

#### step 1 (original)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree15_3">5</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="tree15_3">
     3 (Xed out)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       1 (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     10
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

#### step 2

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     10 (right)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

#### step 3

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     1
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     10
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

<h3 id="ex_fig_4">Example Figure #4</h3>

remove(10)

#### step 1 (original)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree14_10">4</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="tree14_10">
     10 (Xed out)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7 (left)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         6
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           5 (left)
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         8
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

#### step 2

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   4
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2 (left)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->
<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   7
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       5 (left
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

#### step 3

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   4
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         5 (left
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

<h2 id="case3">BST remove: Case 3 Preperation: Successors</h2>

* In an ordered collection $$X=\langle \cdots s_{i-1}, s_{i}, s_{i+1}, s_{i+2} \cdots \rangle$$
  * $$s_{i-1}$$ is the predocessor of $$s_{i}$$
  * $$s_{i+1}$$ is the successor if $$s_{i}$$
  * Write: $$\text{succ}_{x}(s_{i}) = s_{i+1}$$
* Let $$V=\langle v_{1},\cdots v_{n}\rangle$$ be the nodes of the tree ordered as per an in-order traversal.
* Let $$K=\langle k_{1},\cdots ,k_{n}$$\rangle$$ be the keys, in non-decreasing order.
* Then: $$y=\text{key}(u) \implies \text{succ}_{k}(y) = \text{key}(\text{succ}_{v}(u))$$ i.e., the next node has the next key.

## BST remove: Case 3 Preperation: Successorts in BSTs

* If S is a set of keys, and $$x\in S$$, then the *successor of x* in S is the smallest value $$y\in S \text{ s.t. } x< y$$.
Ex. $$S=\{ 19, 27, 8, 3, 12 \}, \text{succ}(8)=12, \text{succ}(12)=19, \cdots$$ $$(S=\{3,8,12,19,27\})$$
* In a BST, in-order traversal visits keys in order.
  * Let S be the set of keys in BST T.
  * the successor of `x` in S is $$\text{key}(u)$$ where u is the node of T that an in-order traversal of T visits next after v.

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2 (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* If v is a node of BST T, then we can say the successor of v in T is the node of T visited just after v by an in-order traversal of T. Then: $$\text{succ}(x)=\text{key}(\text{succ}(\text{node}(x)))$$
* Or: if $$\text{key}(v)=x$$, we can find the successor of x by finding the successor node of v, and getting its key: $$\text{succ}(\text{key}(v)) = \text{key}(\text{succ}(v))$$

## BST remove: Case 3 Preperation: Successors

If node v has a right child, it is easy to find its *successor*: $$\text{succ}(v)$$ is the first node visited by an in-order traversal of the right subtree of v.

Ex. 6 diagrams. All of which give v a right subtree, one of one node, one of one node with a left child, one with a left leaf and right subtree of its own, and three variations on arbitrary numbers of children attached to the left node of v.

To find the successor of node v that has a right child, use:

```
succ(v){
  u<-right(v)
  while(left(u) exists){
    u<-left(u)
  }
  return u
}
```

## BST remove(t)

Case 3: t is at a node with 2 children:

1. find the node v with key(v)=t
2. find the successor of v -- call it u.
3. key(v)<-key(u) //replace t with succ(t) at v.
4. delete u:
    1. if u is a leaf, delete it.
    2. if u is not a leaf, it has one child w, replace u with the subtree rooted at w.

Notice: 4.1 is like case 1; 4.2 is like case 2.

## BST remove(k) when node(k) has two children

Ex. to remove 5:

1. Find 5
2. Find successor of 5
3. Replace 5 with its succ.
4. In this example, succ(5) has no children so just delete the node where it was.

Example tree:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree15_15">20</a> (link starts step 1.)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="tree15_15">
     <a href="#tree15_5">15</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="tree15_5">
       <a href="#tree15_10">5</a> (left; Xed out; link starts step 2.)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         2
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="tree15_10">
          <a href="#tree15_7">10</a>
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="tree15_10">
           <a href="#tree15_6">7</a>
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="tree15_6">
             6 (successor of 5)
            </span>
           </li>
           <li role="treeitem" tabindex="-1">
            <span>
             8
            </span>
           </li>
          </ul>
         </li>
         <li role="treeitem" tabindex="-1">
          <span>
           12
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     25
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       22
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       26
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

After switching 5 and succ(5):

(transcriber's note: may be incorrect, but I'm writing what's there)


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   20
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         7
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           8 (right)
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     ...
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example tree 2:

To remove 6:

1. Find 6
2. Find successor of 6
3. Replace 6 with its successor 
4. Replace succ(6) with its non-empty subtree

Tree:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   <a href="#tree16_2">30</a>
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="tree16_2">
     <a href="#tree16_6">2</a>
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       1
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="tree16_6">
       <a href="#tree16_14">6</a> (crossed out; link starts step 2.)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         ...
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="tree16_14">
         <a href="#tree16_11">14</a>
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="tree16_11">>
           <a href="#tree16_7">11</a>
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="tree16_7">
             7 (succ of 6)
            </span>
            <ul role="group">
             <li role="treeitem" tabindex="-1">
              <span>
               9 (right; subtree of succ(6))
              </span>
              <ul role="group">
               <li role="treeitem" tabindex="-1">
                <span>
                 8 (subtree of succ(6))
                </span>
               </li>
               <li role="treeitem" tabindex="-1">
                <span>
                 10 (subtree of succ(6))
                </span>
               </li>
              </ul>
             </li>
            </ul>
           </li>
           <li role="treeitem" tabindex="-1">
            <span>
             12
            </span>
           </li>
          </ul>
         </li>
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     ...
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Becomes, by step 4:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   30
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       1
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         ...
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         14
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           11
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span>
             9
            </span>
            <ul role="group">
             <li role="treeitem" tabindex="-1">
              <span>
               8
              </span>
             </li>
             <li role="treeitem" tabindex="-1">
              <span>
               10
              </span>
             </li>
            </ul>
           </li>
           <li role="treeitem" tabindex="-1">
            <span>
             12
            </span>
           </li>
          </ul>
         </li>
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     ...
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Complexity of BST Operations

* Measure as a function of: height (h) or size/# of keys (n).
* All operations essentially involve traversing a path from the root to a node v, where in the worst case v is a leaf of maximum depth.
* So:
  * find: O(h), O(n)
  * insert: O(h), O(n)
  * remove: O(h), O(n)
* For "short bushy" trees (e.g. [T1](#fig_t1)) h is small relative in n.
* For "tall skinny" trees (e.g. [T2](#fig_t2)) h is proportional to n.

Q: Can we always have short bushy BSTs?


<h3 id="fig_t1">T1 {% katex %} h = ? {% endkatex %}</h3>

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

<h3 id="fig_t2">T2 {% katex %}h \cong n{% endkatex %}</h3>

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         ...
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           node
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span>
             node
            </span>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Perfect Binary Tree

* A *perfect binary tree* of height h is a binary tree of height h with the max number of nodes:


1 (yes):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

2 (no):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node (left)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

3 (yes):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

4 (yes):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

5 (no):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         node (right)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       node
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         node
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

6 (no):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   node
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node (right)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       node (right)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         node (right)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           node (right)
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* Claim: Every perfect binary tree of height h has $$2^{\text{htl}}-1$$ nodes.
* Pg: By induction on h, or on the structure of the tree.
* Basis: If h=0, there is one node (the root). We have $$2^{\text{htl}}-1 = 2^{1}-1=1$$ as required.
* I.H.: Let $$k \geq o$$, and assume that every perfect binary tree of height k has $$2^{kh}-1$$ nodes.
* T.S.: (Need to show a plot of height k+1 has $$2^{(k+1)+1}-1$$ nodes). A perfect binary tree of height k+1 is constructed as: k is height of left (A) or right (B) subtree; k+1 is the height of the subtree plus one (the root). Where A,B are perfect binary trees of height k.
By I.H. they have $$2^{k+1}-1$$ nodes.
So, the tree has $$2^{k+1}-1 + 2^{k+1}-1 + 1 = 2\times 2^{k+1} -1 = 2^{(k+1)+1}-1$$, as required.

## Existance of Optimal BSTs

Claim: For every set S of n keys, there exists a BST for S with height at most $$1+\log_{2} n$$

Proof: Let h be the smallest integer s.t. $$2^{h} \geq n$$, and let $$m=2^{h}$$.
So, 

{% katex display %}
2^{h} \geq n > 2^{h-1}\\
\log_{2} 2^{h} \geq \log_{2} n > \log_{2} 2^{h-1}\\
h \geq \log_{2} n > h-1\\
h < 1+\log_{2} n
{% endkatex %}

let T be the perfect binary tree of height h

Label the first n nodes of T (as visited by an in-order traversal) with the
keys of S, and delete the remaining
ndoes (to get $$T^{1}$$).

$$T^{1}$$ is a BST for S with height $$h< 1+\log_{2} n$$

So, there is always a BST with height $$O(\log n)$$.

## Optimal BST Insertion Order

Given a set of keys, we can insert them so as to get a minimum height BST:

Consider:

Graph of a perfect tree, with height of 4. Every node has two children, except for the 8 leafs.

What can we say about the key at the root? It is the median key.

Observe: the first key inserted into a BST is at the root forever (unless we remove it from the BST).

Given a set of keys, we can insert them to get a minimum height BST:

(transcriber's note: I may have done this wrong, the drawing of the following tree is very weird.)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

\* apply the "root is the median key" principle to each subtree.

So, there is always a BST with height $$\cong\log n$$

Can we *maintain* min. height with $$O(\log n)$$ as we insert and remove keys?

Consider A:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       4
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6 (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

insert(1) would make it become B:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   4
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       1
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       3
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* B is the *only* min height BST for 1..7.
* A -> B requires "moving every node"
* To get $$O(\log n)$$ operations, we need antoher kind of search tree, other than plain BSTs.
* To get efficient search trees, give up at least one of:
  * binary
  * min height
* Next: self-balancing search trees.

## End (transciber's note: not the end)

(some repeated slides and graphics)

## Notice:

Because a perfect binary tree of height h has:

* h height
* $$2^{h+1}-1$$ nodes
* $$2^{h}-1$$ internal nodes (nodes with children)
* $$2^h$$ leaves

Then: $$2^{h} + 2^{h}-1 = 2\times 2^{h}-1 = 2^{h+1}-1$$

## Actual end
