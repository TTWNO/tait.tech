---
layout: simple
math: true
---

# Priority Queue & Heaps

## PriorityQueue ADT (PQ)

* Stores a collection of pairs (item, priority)
* Priorities are from some ordered set. For simplicity, we use priorities from 0,1,2,... with 0 "highest priority".
* Main operations:
  * insert(item, priority); adds `item` with priority `priority.
  * extract_m/n(); removes (& returns) item with least priority.
  * update(item, priority); changes priority of `item` to `priority`.
* We want a data structure to implement efficient PQs. (e.g. O(log n) time for all operations.
* We (again) will use a particular kind of tree.

## Level - Order Traversal of ordered binary trees.

* visits each node of the tree once.
* visits every node at depth i before any node at depth i+1\*.
* visits every depth-d descendants of left(v) before any depth-d descendant of right(v).

### Diagrams

Order of traversal Diagram 1:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       4
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         8
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         9
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         10
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         11
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         13
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         14
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         15
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Order of traversal diagram 2:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       4
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         8
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           14
          </span>
         </li>
         <li role="treeitem" tabindex="-1">
          <span>
           15
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         9
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         10 (left)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           16 (left)
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span>
             20
            </span>
           </li>
           <li role="treeitem" tabindex="-1">
            <span>
             21
            </span>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         11
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           17
          </span>
         </li>
         <li role="treeitem" tabindex="-1">
          <span>
           18
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span>
             22 (right)
            </span>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         13 (right)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           19
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

\* in some tests, it is bottom-up, not top-down.


## Complete Binary Tree

A complete binary tree of height h is:

1. A binary tree of height h;
2. with $$2^{d}$$ nodes at depth d, for every $$0 \leq d < h$$
3. level order traversal visits every internal node before any leaf
4. every internal node is proper\*, except perhaps the last\*\*, which may have just a left child.

### Diagrams

Example 1: X (4)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child (right)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 2: checkmark

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 3: X (3)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 4: X (4)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 5: checkmark

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 6: checkmark


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 7: checkmark

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 8: X (5)


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 9: X (4)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild (left)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 10: checkmark

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 11: checkmark

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great granchild
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Unlabled tree on next slide:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   ...
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     node at arbitrary depth
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node at arbitrary depth
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node at arbitrary depth
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       child node
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     node at arbitrary depth
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       child node (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Binary Heap Data Structure

* a complete binary tree ("shape invariant")
* with verticies labled by keys (that is: priorities) from some ordered set,
* s.t. $$\text{key}((v) \geq \text{key}(\text{parent}(v))$$ for every node v. ("order invariant")

Example (checkmark:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         7
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example (X):

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     3 (highlighted arrow to 2)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       2
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         7
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6 (highlighted connection to 5)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       5
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

This is the basic DS for implementing PQs (binary min-heap).

<hr>

* How do we implement the operators so that invariants are maintained?
* Consider Insertion: If we want to insert 14 into the heap, where should it go?

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root (complete tree)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     ... (anbiguous number of node/depth)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         20
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     ... (anbiguous number of node/depth)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       11
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         13
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         19
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span>
           ...
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Notice: there no choice about how the *shape* changes:

Example 1:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         inserted node (left)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 2:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         inserted node
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Example 3:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         great grandchild
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         inserted node (left)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Heap Insert

To insert an item with key k:

1. add a new leaf v with key(v)=k, so as to maintain the shape invariant.
2. re-establish the order invariant by executing percolate_up(v).

Code:

```
percolate_up(v){
  while(v is not root and key(v) < key(parent(v))) {
    swap positions of v and parent(v) in the tree
  }
}
```

## Insert 2, then 4, then 3 into:

Original:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     5
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       9
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Insert 2:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2 (5 is crossed out)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       5 (9,2 are crossed out, arrow pointing to parent)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         9 (2 is coressed out, arrow pointing to parent, left)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

insert 4:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       4 (5 is corssed out, arrow pointing to parent)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         9
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         5 (4 is coressed out, arrow pointing to parent)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Insert 3:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         12
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         4
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       4
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         9
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span>
         5
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     3 (6 is crossed out, double sided arrow to/from parent)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6 (10, 3 are crossed out, double sided arrow to/from parent)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         10 (3 is corssed out, double sised arrow to/from parent, left)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Becomes:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       ...
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     3
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span>
         10 (left)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Heap Extract-Min:

Consider (need result of dot dot dots):


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   5
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     ... (left)
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     ... (right)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

We must replace the root with the *smaller* of its children:

Diagram labled "OK":

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   ?
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     6 (arrow towards root)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Diagram labled "NOT OK":

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   ?
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       10
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     6 (arrow towards root)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Heap Extract-Min

To remove the (item with the) smalled key form the heap:

1. rename the root
2. replace the root with the "last leaf", so as to maintain the shape invariant.
3. restore the order invariant by calling percolate_down(root)

Percolate_down is more work than percolate_up,
because it must look at *both* children
to see what to do (and the children may or may not exist)

Code:

```
percolate_down(v){
  while(v has a child c with key(c) < key(v)){
    c <- child of v with the smallest key among the children of v.
    swap v and c in the tree
  }
}
```

Notice that:

* v may have 0, 1 or 2 children 
* if v has 2 children, we care about the one with the smallest key.

## Do extract-min 3 times

Original:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     4
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       11
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       7
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

First extract-min:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   4 (7, 1 are crossed out)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       8
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7 (4 crossed out)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       11
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       (7 crossed out)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Second extract-min:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   6 (4, 11 are crossed out)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     8 (6, 11 are crossed out)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       11 (8 is crossed out)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       (11 crossed out, left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Third extract-min:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   7 (6, 11 are crossed out)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       12
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span>
       (11 is crossed out)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     11 (7 is crossed out)
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Final form:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span>
   7
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span>
     8
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span>
       12 (left)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span>
     11
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Complexity of Heap Insert & Extract-min

* Claim: Insert & Extract-min take time O(log n) for heaps of size n.
* Recall: A perfect binary tree of height h has $$2^{h+1}-1$$ nodes.
* P.f.: By induction on h (or "the structure of the tree").
  * Basis: If h=0 then we have $$2^{0-1} -1 = 1$$ nodes. (checkmark)
  * I.H.: Consider some $$h\geq 0$$ and assume the perfect binary tree of height h has $$2^{h+1} -1$$ nodes.
  * I.S.: show the p.b.t. of height h+1 has $$2^{(h+1)+1}-1$$ nodes.
    * The tree is: diagram of tree with left/right being of height h, and left/right plus the parent is h+1.
    * So it has $$2^{h+1} -1 + 2^{h+1} -1 +1 = 2 \times 2^{h+1}-1 = 2^{(h+1)+1}-1$$ nodes. (circle with line through it)

## Size bounds on complete binary trees

* Every complete binary tree with height h and n nodes satisfies: $$2^{h} \leq n \leq 2^{h+1}-1$$
  * Smallest: (diagram of p.b.t. with height h and one node attached in the farthest left); #nodes = $$2^{(h+1)+1}-1+1 = 2^h$$
  * Largest: (diagram of p.b.t. with height h fully filled)
* So, we have:

{% katex display %}
\begin{aligned}
2^{h} & \leq n\\
\log_{2} 2^{h} & \leq \log_{2} n\\
h & \leq \log_{2} n\\
h & = O(\log n)
\end{aligned}
{% endkatex %}

Heap insert & extract min take time O(log n)

## Linked Implementation of Heap

* [root](#t1_2)
* [last](#t1_3)
* [last](#t1_5)

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t1_2">
   2 (<a href="#t1_4">left</a>, <a href="#t1_3">right</a>, parent is null)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t1_4">
     4 (<a href="#t1_7">left</a>, <a href="#t1_8">right</a>, <a href="#t1_2">parent</a>)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t1_7">
       7 (left=null, right=null, <a href="#t1_4">parent</a>)
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t1_8">
       8 (left=null, right=null, <a href="#t1_4">parent</a>)
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t1_3">
     3 (<a href="#t1_5">left</a>, right=null, <a href="#t1_2">parent</a>)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t1_5">
       5 (left=nill, right=null, <a href="#t1_3">parent</a>)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Node:

* data
* left
* right
* parent

## Array-Based Binary Heap Implementation

Uses this embedding of a complete binary tree of size n in a size-n array:

Tree version:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t2_0">
   0
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t2_1">
     1
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t2_3">
       3
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t2_7">
         7
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t2_8">
         8
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t2_4">
       4
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t2_9">
         9
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t2_10">
         10
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t2_2">
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t2_5">
       5
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t2_11">
         11
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t2_12">
          12 (inserted)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t2_6">
       6
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Becomes, array version:

* 0
* 1
* 2
* 3
* 4
* 5
* 7
* 8
* 9
* 10
* 11
* (inserted) 12

ith ndoe in level-order traversal becomes ith array element.

* Children of node i are nodes 2i+1 & 2i+2
* Parent of node i is node $$\lfloor (i-1)/2\rfloor$$

* 0 [arrow 1](#a1), [arrow 2](#a2)
* <span id="a1">1</span> [arrow 1](#a3) [arrow 2](#a4)
* <span id="a2">2</span> [arrow 1](#a5) [arrow 2](#a6)
* <span id="a3">3</span> [arrow 1](#a7) [arrow 2](#a8)
* <span id="a4">4</span>
* <span id="a5">5</span>
* <span id="a6">6</span>
* <span id="a7">7</span>
* <span id="a8">8</span>
* <span id="a9">9</span>
* <span id="a10">10</span>
* <span id="a11">11</span>
* <span id="a12">12</span>

\* growing and shrinking the tree is easy in the array embedding.

## Partially-filled Array Implementation of Binary Heap: *Insert*

Original:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t3_2">
   2
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t3_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t3_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t3_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t3_6">
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t3_9">
       9 (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

equals:

1. <span id="a2_2">2</span> [left](#a2_7), [right](#a2_6)
2. <span id="a2_7">7</span> [left](#a2_8), [right](#a2_10)
3. <span id="a2_6">6</span>
4. <span id="a2_8">8</span>
5. <span id="a2_10">10</span>
6. <span id="a2_4">4</span>

Insert 1:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t3_2">
   2
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t3_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t3_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t3_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t3_6">
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t3_9">
       9
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t3_1">
       (inserted) 1
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

array implementation:

1. <span id="a5_2">2</span> ([left](#a5_7), [right](#a5_6))
2. <span id="a5_7">7</span> ([left](#a5_8), [right](#a5_10))
3. <span id="a5_6">6</span> ([left](#a5_9))
4. <span id="a5_8">8</span>
5. <span id="a5_10">10</span>
6. <span id="a5_9">9</span>
7. (inserted) 1

Becomes:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t4_1">
   1
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t4_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t4_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t4_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t4_2">
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t4_9">
       9
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t4_6">
       6
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Array implementation:

1. 1
2. 7
3. 2
4. 8
5. 10
6. 9
7. 6

Additional diagram:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t6_1">
   1 (2 is crossed out, arrow to 2)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t6_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t6_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t6_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t6_2">
     2 (6 is crossed out, arrow to 6)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t6_9">
       9
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t6_6">
       6 (1 is crossed out)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

In array form:

1. <span id="a9_1">1 (2 is crossed out)</span> ([left](#a9_7), [right](#a9_2))
2. <span id="a9_7">7</span> ([left](#a9_8), [right](#a9_10))
3. <span id="a9_2">2 (6, 1 are crossed out)</span>
4. <span id="a9_8">8</span>
5. <span id="a9_10">10</span>
6. <span id="a9_9">9</span>
7. <span id="a9_6">6 (1 is crossed out)</span>

## Insert for Array-based Heap

* Variables: array A, size
* Heap element are in $$A[0] \cdots A[\text{size}-1]$$

```
insert(k){
  A[size] <- k; // Add k to the new 'last leaf'
  v <- size
  p <- floor((v-1)/2) // p <- parent(v); percolate_up
  while(v>0 and A[v]<A[p]){
    swap A[v] and A[p]
    v <- p
    p <- floor((v-1)/2)
  }// end of percolate_up
  size <- size + 1;
}
```

## Partially-filled Array Implementation of Binary Heap: Extract-min

Original tree:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t7_2">
   2
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t7_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t7_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t7_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t7_6">
     6
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t7_9">
       9
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t7_11">
       11
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Array implemntation:

1. <span id="a10_2">2</span> ([left](#a10_7), [right](#a10_6))
2. <span id="a10_7">7</span> ([left](#a10_8), [right](#a10_10))
3. <span id="a10_6">6</span>
4. <span id="a10_8">8</span>
5. <span id="a10_10">10</span>
6. <span id="a10_9">9</span>
7. <span id="a10_11">11</span>

After extract-min, tree:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t7_6">
   6
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t7_7">
     7
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t7_8">
       8
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t7_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t7_9">
     9
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t7_11">
       11 (left)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Array implementation:

1. 6
2. 7
3. 9
4. 8
5. 10
6. 11

After another extract-min, tree:


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t7_7">
   7
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t7_8">
     8
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t7_11">
       11
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t7_10">
       10
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t7_9">
     9
    </span>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

## Extract_min for Array-based Heap

Code:

```
extract_min(){
  temp <- A[0] // record value to return
  size <- size-1
  A[0] <- A[size] // move *old* last leaf to root
  i <- 0 // percolate down
  while(2i+1<size){// while i not a leaf
    child <- 2i+1 // the left child of i
    if(2i+2<size and A[2i+2] < A[2i+1]){
      child <- 2i+2 // use the right child if it exists and a smaller key
    }
    if(A[child]<A[i]){ // if order violated,
      swap A[child] and A[i] // swap parent+child
    } else {
      return temp
    }
  } // percolate-down
  return temp.
}
```

## A small space-for-time trade-off in Extract-min

* Extract-min does many comparisons, e.g. ($$2i < \text{size}) to check if i is a leaf.
* Suppose we ensure the array has $$\text{size} \geq 2\times \text{size}$$
*and* there is a big value, denoted $$\infty$$, that can be stored in the array but will never be a key.
*and* every array entry that is not a key is $$\infty$$.
* Then, we can skip the explicit checks for being a leaf.

## Extract-min variant

Code:

```
extract_min(){
  temp <- A[0] // record value to return
  size <- size-1
  A[0] <- A[size] // move *old* last leaf to root
  A[size] <- inf // **
  i <- 0 // percolate down
  while(A[2i+1]+A[i] *or* A[2i+2]+A[i]){ // i has a child that is out of order
    if(A[2i+1]<A[2i+2]){ //if is a left child
      swap A[2i+1] and A[i]
      i <- 2i+1
    } else { //it is a right child
      swap A[2i+2] and A[i]
      i <- 2i+2
    }
  }
  return temp
}
```

## Making a Heap from a Set

* Suppose you have n keys and want to make a heap with them.
* Clearly can be done in time O(n log n)with n inserts.
* Claim: the following alg. does it in time O(n).

```
make_heap(T){
  //T is a complete b.t. with n keys.
  for(i=floor(n/2)-1 down to 0){
    call percolate_down on node i
  }
}
```

## How does make-heap work?

* $$\lfloor n/2 \rfloor -1$$ is the last internal node
* the algorithm does a percolate-down at each internal node, working bottom-up.
  * (percolate_down makes a tree into a heap if the only node violating the order properly is the root)

Tree diagram:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t8_0">
   0
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t8_1">
     1
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t8_3">
       3
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t8_7">
         7
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t8_15">
           15
          </span>
         </li>
         <li role="treeitem" tabindex="-1">
          <span id="t8_16">
           16
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t8_8">
         8
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t8_17">
           17
          </span>
         </li>
         <li role="treeitem" tabindex="-1">
          <span id="t8_18">
           18
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t8_4">
       4
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t8_9">
         9 (label: last internal node)
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t8_19">
           19
          </span>
         </li>
         <li role="treeitem" tabindex="-1">
          <span id="t8_20">
           20
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t8_10">
         10
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t8_2">
     2
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t8_5">
       5
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t8_11">
         11
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t8_12">
         12
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t8_6">
       6
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t8_13">
         13
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t8_14">
         14
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Last internal node equation: $$\lfloor \frac{n}{2} \rfloor -1 = \lfloor \frac{21}{2} \rfloor -1 = 9$$

## Make heap example

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t9_10">
   10 (0)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t9_9">
     9 (1)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t9_7">
       7 (3)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t9_3">
         3
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t9_2">
         2
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t9_6">
       6 (4)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t9_1">
         1 (left)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t9_8">
     8 (2)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t9_5">
       5
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t9_4">
       4
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Note: $$n=10$$; $$\lfloor n/2 \rfloor -1 =4$$

Notice: The exact order of visitng nodes does not matter -- as long as we visit children before parents. [It follows that it is easy to do a recursive make-heap]

## Make heap Example

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t9_1">
   1 (0; 10 is crossed out)
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t9_2">
     2 (1; 9, 10 are crossed out; checkmark)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t9_3">
       3 (3; 10, 2, 7 are crossed out; checkmark))
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t9_10">
         10 (3 is crossed out; checkmark)
        </span>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t9_7">
         7 (2 is crossed out; checkmark)
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t9_6">
       6 (4; 6, 1 are crossed out; checkmark)
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t9_9">
         9 (left; 1,6 are crossed out)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t9_4">
     4 (2; 8 is crossed out; checkmark)
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t9_5">
       5
      </span>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t9_8">
       8 (4 is crossed out)
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Note: $$n=10$$; $$\lfloor n/2 \rfloor -1 = 4$$

Notice: The exact order of visitng nodes does not matter -- as long as we visit children before parents. [It follows that it is easy to do a recursive make-heap]

## Make-heap Complexity

* Clearly O(n log n): n percolate-down calls, each O(log n).
* How can we see it is actually O(n)?
* Intuition: mark a distinct edge for for *every possible swap* (Time taken is bounded by max. # of swaps possible.)

Diagram of a perfect binary tree with h=5. It is missing the rightmost 4 at h=5.
Easier than using a tree.

## Time Complexity of Make-heap

* Let S(n) be the max number of swaps carried out by make-heap on a set of size n.
* We can bound S(n) by:

{% katex display %}
S(n) \leq \sum_{d=0}^{h-1} 2^{d} (h-d)
{% endkatex %}

Explanation:

Part|Note
---|---
{% katex display %}\sum_{d=0}^{h-1}{% endkatex %}|percolate_down is called, at most on each node at each depth d from 0 to h-1
{% katex display %}2^{d}{% endkatex %}|there are $$2^{d}$$ nodes at depth d
{% katex display %}(h-d){% endkatex %}|The max # of swaps for a call to percolate-down on a node at depth d is h-d

<hr>

{% katex display %}
\begin{aligned}
S(n) & \leq \sum_{d=0}^{h-1} 2^{d} (h-d)\\
& = 2^{0} (h-0) + 2^1 (h-1) + \cdots + 2^{h-2} (h(h-2)) + h^{h-1} (h-(h-1))
\end{aligned}
{% endkatex %}

Set $$i=h=d$$, $$d=h=i$$ and while d ranges over $$0,1,\cdots,h-1$$, i will range over $$h-0,h-1,\cdots,h-(h-1)$$

Now:

{% katex display %}
\begin{aligned}
S(n) \leq \sum_{i=1}^{h} 2^{h-i} (i) & =
\sum_{i=1}^{h} \frac{2^{h}}{2^i} i \leq \sum_{i=1}^{h} \frac{n}{2^i} i\\
& = n \sum_{i=1}^{h} \frac{i}{2^i} \leq n \sum_{i=0}^{h} \frac{i}{2^i} \leq 2n
\end{aligned}
{% endkatex %}

{% katex display %}
\Bigg ( \sum_{i=0}^{h} \frac{i}{2^i} = \frac{0}{2^0} + \frac{1}{2^1} + \frac{2}{2^2} + \frac{3}{2^3} + \cdots
= \frac{1}{2} + \frac{1}{2} + \frac{3}{8} + \frac{1}{4} + \frac{5}{32} + \cdots \Bigg )
{% endkatex %}

Everything after $$\frac{3}{8}$$ is less than or equal to 1.

## Complexity of Make-heap

Work done by make-heap is bounded by a constant times the number of swaps so is O(n).

## Updating Priorities

* Suppose a heap contains an item with priority k,
and we execute update_priority(item, j).
* We replace k with j in the heap, and then restore the order invariant:
  * ```
if j < k, do percolate_up from the modified node
if k < j, do percolate_down from the modified node.
```

Tree 1:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t10_unlabled">
   unlabled root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t10_unlabled">
     unlabled child
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t10_unlabled">
     unlabled child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t10_unlabled">
       unlabled grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t10_unlabled">
         unlabled great-grandchild
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t10_...">
           ...
          </span>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t10_unlabled">
         unlabled great-grandchild
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t10_...">
           ...
          </span>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t10_unlabled">
       unlabled grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

Tree 2:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t10_unlabled">
   unlabled root
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t10_unlabled">
     unlabled child
    </span>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t10_unlabled">
     unlabled child
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t10_unlabled">
       unlabled grandchild
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t10_unlabled">
         unlabled great-grandchild
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t10_unlabled">
           unlabled great-great-grandchild
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="t10_...">
             ...
            </span>
           </li>
          </ul>
         </li>
         <li role="treeitem" tabindex="-1">
          <span id="t10_unlabled">
           unlabled great-great-grandchild
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="t10_...">
             ...
            </span>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li role="treeitem" tabindex="-1">
        <span id="t10_unlabled">
         unlabled great-grandchild
        </span>
        <ul role="group">
         <li role="treeitem" tabindex="-1">
          <span id="t10_unlabled">
           unlabled great-great-grandchild
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="t10_...">
             ...
            </span>
           </li>
          </ul>
         </li>
         <li role="treeitem" tabindex="-1">
          <span id="t10_unlabled">
           unlabled great-great-grandchild
          </span>
          <ul role="group">
           <li role="treeitem" tabindex="-1">
            <span id="t10_...">
             ...
            </span>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t10_unlabled">
       unlabled grandchild
      </span>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* This (restarting ???, can't read ???) takes O(log n) time -- *but* how do we find the right node to change??
* To do this we need an auxiliary data structure.

## End (transcriber's note: not the end)

## Correctness of swapping in percolate down


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t11_b">
   b
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t11_a">
     a
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_...">
       ...
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t11_c">
     c
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_d">
       d
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t11_e">
       e
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* Suppose we use percolating down c
* Then c and b were previously swapped,
so we know $$b\leq e$$, $$b\leq d$$, and $$b < c$$.
* If $$c > e$$ and $$e \leq d$$, we swap c,e

Now:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t11_b">
   b
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t11_a">
     a
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_...">
       ...
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t11_e">
     e
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_d">
       d
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t11_c">
       c
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* we know $$b\leq e \leq c$$ and $$b\leq e \leq d$$
* so order is OK, except possible below c--which we will have to look at.

## Correctness of swapping in percolate_up


<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t11_b">
   b
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t11_a">
     a
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_...">
       ...
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t11_c">
     c
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_d">
       d
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t11_e">
       e
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* suppose we are percolating up c
* we know $$c\leq d, c\leq e$$ because we previously swapped c with d or e.
* we know that $$b\leq a$$
* if $$c< b$$, we swap c,b

Now:

<!-- AUTO GENERATED FROM CUSTOM PYTHON CODE -->
<ul role="tree">
 <li role="treeitem" tabindex="-1">
  <span id="t11_c">
   c
  </span>
  <ul role="group">
   <li role="treeitem" tabindex="-1">
    <span id="t11_a">
     a
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_...">
       ...
      </span>
     </li>
    </ul>
   </li>
   <li role="treeitem" tabindex="-1">
    <span id="t11_b">
     b
    </span>
    <ul role="group">
     <li role="treeitem" tabindex="-1">
      <span id="t11_d">
       d
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ...
        </span>
       </li>
      </ul>
     </li>
     <li role="treeitem" tabindex="-1">
      <span id="t11_e">
       e
      </span>
      <ul role="group">
       <li role="treeitem" tabindex="-1">
        <span id="t11_...">
         ... (T3)
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
<!-- END OF GENERATED CODE -->

* we know that $$c < b \leq e$$ and $$c < b \leq d$$ and $$c < b \leq a$$
* So order is OK, except possibly with ancestors of c, which we still must check.
