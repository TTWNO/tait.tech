---
title: "Idea For A VPN Service"
layout: post
math: true
---

Recently I've been thinking about starting a VPN service.
This service has some interesting requirements that I have never seen a VPN service do before, so I'd liKe to put down my thoughts as to what might be sensible for a centralized by encrypted VPN service.

I would license all the code and scripts under the AGPLv3.
This creates an environment where I could allow my company to use this code, and any other company for that matter but no company would be allowed to take it into their own hands and use it without contributing back to the project.

## E2EE VPN

I want this service in many ways to copy [ProtonMail](https://protonmail.com):
end-to-end encrypted (E2EE), and with a focus in data security for the user of the service.

Full encryption, so that even me, the writer and the deployer of the service, cannot view any information about the user: this is the utmost security.
The bad news is that this is very hard to do in a convenient way.
I've decided for now that the best thing to do is to target the Linux nerd.
Target the user who is familiar with these advanced security practices, then make them available to the general public as the layers on top of the robust security are refined.

## Why?

End-to-end encryption is necessary in a country like Canada, where I may be sent a subpoena to provide customer data.
This is the case especially in the [Five Eyes](https://en.wikipedia.org/wiki/Five_Eyes) anglophone group of countries, who essentially spy on each others' citizens for their allies.
In essence, any data in the hand of one government agency may be shared between the Five, Nine, and 14 Eyes countries.

## What We Need

A VPN service needs access to some basic information:
1. Service discontinue time (the amount of time until the customer must renew).
2. Active connections.

The client needs access to some information from the server as well:
1. A list of VPNs able to be connected to (with filters).
2. For every VPN:
   1. IP Address.
   2. Maximum bandwidth.
   3. Number of connected users or connection saturation percentage.
   4. Supported protocols.

Can we do this in a end-to-end encrypted fashion?
I'm honestly not sure. But here are my ideas so far as to how *some* of these functions might work.

## How To Do It

### "Usernames"

There will be one button to create your account: *"Generate username"*
The username, or unique identifier for a user will be generated for them by a random generator.
I plan to generate a username from a list of [Base 64](https://en.wikipedia.org/wiki/Base64) characters; it will be a guaranteed length of 16.
This gives a total of: `79228162514264337593543950336` or {% katex %}7.9 \times 10^{28}{% endkatex %} posibilities.
This is sufficient for a username.

The other option is to use a standard "username" field that uses a modern hash function like [SHA512](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms) to store it in the database.
This is less secure as it is vulnerable to a brute-force attack of finding users,
but this is also a very easy attack to defend against, i.e. IP banning after 10-ish tries of not finding a username.

A *non-unique, universal* salt will also be used on each username to make it more secure.
This decreases the possibility of an advanced attacker being able to find usernames in a leaked database.
That said, the fact that it is a fixed salt makes it much more vulnerable to an attack.
Although it would be known only by the server machine, it would still be somewhat of a vulnerability.
The operator may also store the salt in an encrypted password store of their own in case the server is erased, broken into, etc.
It would be fairly easy, if they have access to the active salt, to migrate to a new salt every few days/months, or perhaps every time a server change happens.
In the end, they would need a backup of this salt, otherwise login times would become linear to the number of users as the database checks every user's salt to see if it matches the hash made with the username input.

So, here's the overview:
The username will be generated, then stored *after* being salted and hashed.
The salt will be a fixed or rolling salt across all usernames to avoid linear scaling of searching for a user.
The server will only see the username once, when sending it to the user for them to save for the first time;
there will be no database entry with the original username in it.

This does mean that if the username is lost, the account is lost too. There is no way to recover the account.

### "Passwords"

There are a few options for passwords/secret keys.

I think the best is to treat it similarly to the username is above, except it will *not* be generated for you.
When a new account is generated, you will be taken to a password reset screen where you will set your password to whatever your want, using your own secure system to handle it.
This is ideal for Linux and tech enthusiasts as they generally already have a password management system setup.

This will also be salted, with its own unique salt, then hashed and stored alongside the username.

### Active Time Remaining

It is easy and ideal to have a field connected to a user with their expiry date for their account.
When a payment is made, this date will be increased by the number of days, hours and minutes proportional to the payment received.

This is the second biggest threat to the users' data privacy, as this, by definition, cannot be encrypted as my server needs access to this data to decide whether a user should be allowed to: view a list of VPN nodes available to them or connect to a VPN.
The best I can do in this case is make sure the database and root hard disk are fully encrypted with a password on boot so if asked for data I can simply shut it down.

This is not a fantastic solution, and still has the threat of a service provider snooping in on the database.
The truth is: a service provider has root access to any machine it hosts.
This necessitates that the *physical* infrastructure hosting the central database server must by physically owned and operated by the VPN operator.
In addition, it means top security root passwords, tamper resistant cases (in the case of a co-hosting or server room environment), sensors to indicate it has been opened or touched.
If you thoughts this was bad, wait until the next part.

### Active Connections

In order to stop a user from simply using the entire bandwidth of all my VPN nodes available to them, I need a way to know how many active connections the user has.
This is *by far* the biggest issue in terms of user privacy.
There are a few options here:
1. Do not have a limit on the number of connections a user may have. This is dangerous from a DDoS (distributed denial of service) perspective.
2. Have a list of connected users sent to the central server every 15 to 30 seconds. This is fairly efficient, but more privacy invasive.
3. ???

This section is very tough.
